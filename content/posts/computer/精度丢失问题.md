---
title: "浮点型的“精度丢失”的原因以及解决方案"
date: 2024-03-27T21:30:20+08:00
tags: ["计算机基础"]
draft: false

---

## ` 单精度 ` & ` 双精度 `

> `单精度浮点数`（float32）采用 32 位表示，其中包括 1 位符号位、8 位整数位 、23 位尾数位。<br />
`双精度浮点数`（float64）采用 64 位表示，其中包括 1 位符号位、11 位整数位、 52 位尾数位。

```markdown
例如表示：0.1
float32：0.1 ≈ 0.00011001100110011001100（其实是无限循环 0011，这里相当于截取了）
float64：0.1 ≈ 0.0001100110011001100110011001100110011001100110011001（其实是无限循环 0011，这里相当于截取了）
```

## 浮点型在计算机中的表示

```markdown
# 0.1 为例（float32）
0.1 * 2 = 0.2  => 0
0.2 * 2 = 0.4  => 0
0.4 * 2 = 0.8  => 0
0.8 * 2 = 1.6  => 1
0.6 * 2 = 1.2  => 1
0.2 * 2 = 0.4  => 0 // 发现到了这里又回到了 0.4 ，所以 0.4 就是循环开始的地方，也就是 0011
整数位为 0
小数位表示为：00011001100110011001100（无限循环 0011）
整体表示为：0.00011001100110011001100（其实是无限循环 0011，这里相当于截取）

# 1.1 为例（float32）
整数位为 0001
小数位为 00011001100110011001100（无限循环 0011）
整体表示为：1.00011001100110011001100（其实是无限循环 0011，这里相当于截取）
```

## 精度丢失问题

### 场景

```go
a := 0.1
b := 0.2

fmt.Println(a + b) // 0.30000000000000004
```

### 原因

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为计算机是使用二进制来表示小数的，可是很多小数都是无限循环的，可是不管是 float32 还是 float64 能表示的范围都是有限的，也就是说 float 会对无限循环的二进制进行裁切，所以我们取的其实只是该数的一个近似值，最终拿这个近似值去计算自然也只是会得到一个近似结果，不会得到确切的结果。

### 解决

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般我们均是采用 decimal 类型来进行处理。

```go
decimalA.Add(decimalB) // 加
decimalA.Sub(decimalB) // 减
decimalA.Mul(decimalB) // 乘
decimalA.Div(decimalB) // 除
```
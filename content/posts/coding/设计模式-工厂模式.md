---
title: "设计模式之《工厂模式》"
date: 2022-03-27T21:30:21+08:00
tags: ["设计模式"]
draft: false

---

## 简单工厂模式

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**简单工厂模式**(Simple Factory Pattern)：又称为**静态工厂方法**(Static Factory Method)模式，不是23种基本设计模式中的一种，因为它不符合开闭原则；<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**简单工厂模式**有三个角色：（1）专门定义一个类（工厂角色）来负责创建（2）其他类（具体产品角色）的实例，（3）被创建的实例通常都具有共同的父类（抽象产品角色）。<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;工厂并不一定需要定义一个类，可以就直接定义一个构造方法作为工厂角色就行。

```go
type Animal interface{
    Speak()
}

type Cat struct {
}

func (c *Cat) Speak() {
    // 产品自己的具体实现逻辑
    fmt.Println("喵喵~")
}

type Dog struct {
}

func (d *Dog) Speak() {
    // 产品自己的具体实现逻辑
    fmt.Println("汪汪~")
}

func NewAnimal(typeName string) Animal {

    switch typeName {
        case "cat":
            return &Cat{}
        case "dog":
            return &Dog{}
        default:
            
    }
    
}

func main() {
    tom := NewAnimal("cat")
    tom.Speak()
}
```

- Animal 就是 `抽象产品`
- Cat、Dog 就是 `具体产品`，当然上面的 Cat、Dog 的构造初始化还可以抽取出来，例如 NewCat()
- NewAnimal() 就是 `工厂方法`

## 工厂方法模式

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**工厂方法模式**（Factory Method Pattern）是一种创建型设计模式，它定义了一个用于创建对象的接口，但将对象的实际创建延迟到子类中。这样可以使得创建对象的过程可以在不同的子类中进行定制化，同时将客户端代码与具体对象的创建逻辑解耦。<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**工厂方法模式** 相比较**简单工厂模式**就是把工厂分为了`抽象层`和`具体层`，这么做的目的就是**简单工厂模式**的那个工厂方法职责太重了，抽象一层就会分散工厂方法的压力。

```go
package main

import "fmt"

// Animal 接口定义了动物的行为
type Animal interface {
	Speak() string
}

// AnimalFactory 是一个接口，定义了创建动物对象的方法
type AnimalFactory interface {
	CreateAnimal() Animal
}

// DogFactory 实现了 AnimalFactory 接口，用于创建狗对象
type DogFactory struct{}

// CreateAnimal 实现了 DogFactory 的 CreateAnimal 方法
func (df DogFactory) CreateAnimal() Animal {
	return Dog{}
}

// Dog 结构体实现了 Animal 接口
type Dog struct{}

// Speak 实现了 Dog 的 Speak 方法
func (d Dog) Speak() string {
	return "Woof!"
}

// CatFactory 实现了 AnimalFactory 接口，用于创建猫对象
type CatFactory struct{}

// CreateAnimal 实现了 CatFactory 的 CreateAnimal 方法
func (cf CatFactory) CreateAnimal() Animal {
	return Cat{}
}

// Cat 结构体实现了 Animal 接口
type Cat struct{}

// Speak 实现了 Cat 的 Speak 方法
func (c Cat) Speak() string {
	return "Meow!"
}

func main() {
	// 创建狗工厂
	dogFactory := DogFactory{}
	// 使用狗工厂创建狗对象
	dog := dogFactory.CreateAnimal()

	// 创建猫工厂
	catFactory := CatFactory{}
	// 使用猫工厂创建猫对象
	cat := catFactory.CreateAnimal()

	// 调用动物对象的 Speak 方法
	fmt.Println(dog.Speak()) // 输出: Woof!
	fmt.Println(cat.Speak()) // 输出: Meow!
}
```

